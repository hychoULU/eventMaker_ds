<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> DS Event Editor - v2.8.6 </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .pattern-grid {
            background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .canvas-container {
            position: relative;
            min-height: 1000px;
            min-width: 2500px;
        }
        svg.connection-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .node-card {
            z-index: 10;
            height: auto;
        }
        .drop-target-active {
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);
            border-color: #3b82f6 !important;
        }
        .choice-drop-target-active {
            background-color: #ebf5ff !important;
            border-color: #3b82f6 !important;
            transform: scale(1.02);
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fadeIn {
            animation: fadeIn 0.2s ease-out;
        }
        .tooltip {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1f2937;
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 200;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .connection-label {
            font-size: 11px;
            font-weight: 800;
            fill: #2563eb;
            paint-order: stroke;
            stroke: #ffffff;
            stroke-width: 4px;
            cursor: pointer;
            pointer-events: auto;
        }
        .ctx-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 4px;
            z-index: 500;
            min-width: 120px;
        }
        .weight-input-box {
            position: fixed;
            z-index: 1000;
            transform: translate(-50%, -50%);
            background: white;
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            border: 2px solid #3b82f6;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        const Icon = ({ name, size = 16, className = "" }) => {
            const icons = {
                Plus: <path d="M12 5v14M5 12h14" />,
                Trash2: <><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><path d="M10 11v6M14 11v6" /></>,
                ArrowRight: <path d="M5 12h14M12 5l7 7-7 7" />,
                Download: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />,
                Upload: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" />,
                GitBranch: <><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9" /></>,
                AlertTriangle: <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01" />,
                Copy: <path d="M8 4v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7.242a2 2 0 0 0-.602-1.43L17.431 4.22a2 2 0 0 0-1.43-.602H10a2 2 0 0 0-2 2zM4 8v11a3 3 0 0 0 3 3h10" />,
                MousePointer: <path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3zM13 13l6 6" />,
                Info: <><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8" /></>,
                Save: <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>
            };
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        const App = () => {
            const [events, setEvents] = useState([]);
            const [nodes, setNodes] = useState([]);
            const [choices, setChoices] = useState([]);
            
            const [selectedEventId, setSelectedEventId] = useState("");
            const [selectedElement, setSelectedElement] = useState(null);
            const [viewMode, setViewMode] = useState('editor');
            const [deleteModal, setDeleteModal] = useState({ show: false, type: null, id: null });
            const [showImportModal, setShowImportModal] = useState(false);
            const [importText, setImportText] = useState("");
            const [toast, setToast] = useState({ show: false, message: "" });

            const [editingNodeCommentId, setEditingNodeCommentId] = useState(null);
            const [editingChoiceCommentId, setEditingChoiceCommentId] = useState(null);
            const [editingWeightData, setEditingWeightData] = useState(null); 
            const [tempValue, setTempValue] = useState("");

            const [tooltip, setTooltip] = useState({ show: false, x: 0, y: 0, content: "" });
            const [draggingChoiceId, setDraggingChoiceId] = useState(null);
            const [dropTargetId, setDropTargetId] = useState(null);
            const [ctxMenu, setCtxMenu] = useState({ show: false, x: 0, y: 0, type: null, id: null });
            
            const canvasRef = useRef(null);
            const elementRefs = useRef({});

            const [undoStack, setUndoStack] = useState([]);
            const [redoStack, setRedoStack] = useState([]);

            const recordHistory = useCallback(() => {
                const snapshot = JSON.stringify({ events, nodes, choices });
                setUndoStack(prev => [...prev.slice(-49), snapshot]);
                setRedoStack([]);
            }, [events, nodes, choices]);

            const performUndo = useCallback(() => {
                if (undoStack.length === 0) return;
                const currentSnapshot = JSON.stringify({ events, nodes, choices });
                const prevSnapshot = JSON.parse(undoStack[undoStack.length - 1]);
                setRedoStack(prev => [...prev, currentSnapshot]);
                setUndoStack(prev => prev.slice(0, -1));
                setEvents(prevSnapshot.events);
                setNodes(prevSnapshot.nodes);
                setChoices(prevSnapshot.choices);
                showToast("Undo Action");
            }, [undoStack, events, nodes, choices]);

            const performRedo = useCallback(() => {
                if (redoStack.length === 0) return;
                const currentSnapshot = JSON.stringify({ events, nodes, choices });
                const nextSnapshot = JSON.parse(redoStack[redoStack.length - 1]);
                setUndoStack(prev => [...prev, currentSnapshot]);
                setRedoStack(prev => prev.slice(0, -1));
                setEvents(nextSnapshot.events);
                setNodes(nextSnapshot.nodes);
                setChoices(nextSnapshot.choices);
                showToast("Redo Action");
            }, [redoStack, events, nodes, choices]);

            const showToast = (msg) => {
                setToast({ show: true, message: msg });
                setTimeout(() => setToast({ show: false, message: "" }), 2500);
            };

            const downloadJSON = useCallback(() => {
                const dateStr = new Date().toISOString().slice(0,10);
                
                const exportedEvents = events.map(e => ({
                    EventID: e.EventID,
                    DevComment: e.DevComment,
                    StartNodeID: e.StartNodeID,
                    StartCondition: e.StartCondition,
                    TargetUnitCondition: e.TargetUnitCondition,
                    EventType: e.EventType,
                    Weight: e.Weight,
                    IsRepeatable: e.IsRepeatable,
                    CoolDown: e.CoolDown
                }));

                const exportedNodes = nodes.map(n => ({
                    NodeID: n.NodeID,
                    DevComment: n.DevComment,
                    LinkedEventID: n.LinkedEventID,
                    NodeType: n.NodeType,
                    ChoiceIDs: n.ChoiceIDs
                }));

                const exportedChoices = choices.map(c => {
                    const totalW = c.Outcomes.reduce((acc, o) => acc + o.Weight, 0);
                    const actionStr = c.Outcomes.map(o => {
                        const prob = totalW > 0 ? Math.round((o.Weight / totalW) * 100) : 0;
                        return `ShowNextNode_${o.NodeID}_${prob}`;
                    }).join(',');

                    let tooltipType = c.ActiveTooltipType;
                    if (tooltipType === 'ShowChoiceAction' && c.ActiveTooltipValue) {
                        tooltipType = `ShowChoiceAction_${c.ActiveTooltipValue}`;
                    }

                    return {
                        ChoiceID: c.ChoiceID,
                        DevComment: c.DevComment,
                        LinkedNodeID: c.LinkedNodeID,
                        ActiveCondition: c.ActiveCondition,
                        OnSelectAction: actionStr,
                        ActiveTooltipType: tooltipType
                    };
                });

                const data = { "Event시트": exportedEvents, "Node시트": exportedNodes, "Choice시트": exportedChoices };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = `DS_Events_${dateStr}.json`;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                showToast("DS_Events Exported");
            }, [events, nodes, choices]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key.toLowerCase() === 'z') { if (e.shiftKey) performRedo(); else performUndo(); e.preventDefault(); }
                        else if (e.key.toLowerCase() === 's') { downloadJSON(); e.preventDefault(); }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [performUndo, performRedo, downloadJSON]);

            const getEventSummary = (eventId) => {
                if (!eventId) return "E";
                const parts = eventId.split('_'); // Event_Fixed0 -> ["Event", "Fixed0"]
                const typeChar = parts[1] ? parts[1].charAt(0) : "F"; // "F"
                const numMatch = parts[1]?.match(/\d+/);
                return `${typeChar}${numMatch ? numMatch[0] : "0"}`; // "F0"
            };

            const createEvent = (type) => {
                recordHistory();
                const sameTypeEvents = events.filter(e => e.EventType === type);
                const newId = `Event_${type}${sameTypeEvents.length}`;
                const eventSummary = getEventSummary(newId);
                const startNodeId = `Node${eventSummary}00`;
                
                const newEvent = {
                    EventID: newId, DevComment: "New Event", StartNodeID: startNodeId,
                    StartCondition: "None", TargetUnitCondition: "None", EventType: type,
                    Weight: 100, IsRepeatable: false, CoolDown: 0
                };
                const firstNode = {
                    NodeID: startNodeId, DevComment: "Start Point", LinkedEventID: newId,
                    NodeType: "Normal", ChoiceIDs: [], depth: 0
                };
                setEvents([...events, newEvent]);
                setNodes([...nodes, firstNode]);
                setSelectedEventId(newId);
                setSelectedElement({ type: 'event', id: newId });
            };

            const createNode = (depth) => {
                if (!selectedEventId) return;
                recordHistory();
                const eventSummary = getEventSummary(selectedEventId);
                const nodesInDepth = nodes.filter(n => n.LinkedEventID === selectedEventId && n.depth === depth);
                const newId = `Node${eventSummary}${depth}${nodesInDepth.length}`;
                const newNode = {
                    NodeID: newId, DevComment: "Description...", LinkedEventID: selectedEventId,
                    NodeType: "Normal", ChoiceIDs: [], depth: depth
                };
                setNodes([...nodes, newNode]);
                setSelectedElement({ type: 'node', id: newId });
            };

            const createChoice = (nodeId) => {
                const node = nodes.find(n => n.NodeID === nodeId);
                if (!node || node.ChoiceIDs.length >= 3) return;
                recordHistory();
                const eventSummary = getEventSummary(selectedEventId);
                const nodeCoordinate = nodeId.slice(-2);
                const newId = `Choice${eventSummary}${nodeCoordinate}${node.ChoiceIDs.length}`;
                const newChoice = {
                    ChoiceID: newId, DevComment: "New Choice", LinkedNodeID: nodeId,
                    ActiveCondition: "None", Outcomes: [], ActiveTooltipType: "None", ActiveTooltipValue: ""
                };
                setChoices([...choices, newChoice]);
                setNodes(nodes.map(n => n.NodeID === nodeId ? { ...n, ChoiceIDs: [...n.ChoiceIDs, newId] } : n));
                setSelectedElement({ type: 'choice', id: newId });
            };

            // --- Drag & Drop ---
            const onChoiceDragStart = (e, choiceId) => { setDraggingChoiceId(choiceId); e.dataTransfer.setData("choiceId", choiceId); };
            
            const onNodeDragOver = (e, nodeId) => {
                e.preventDefault();
                const choice = choices.find(c => c.ChoiceID === draggingChoiceId);
                if (!choice) return;
                const sourceNode = nodes.find(n => n.NodeID === choice.LinkedNodeID);
                const targetNode = nodes.find(n => n.NodeID === nodeId);
                if (sourceNode && targetNode && targetNode.depth > sourceNode.depth) setDropTargetId(nodeId);
            };

            const onNodeDrop = (e, targetNodeId) => {
                e.preventDefault();
                const choiceId = draggingChoiceId;
                const choice = choices.find(c => c.ChoiceID === choiceId);
                if (!choice) return;
                const sourceNode = nodes.find(n => n.NodeID === choice.LinkedNodeID);
                const targetNode = nodes.find(n => n.NodeID === targetNodeId);
                if (targetNode.depth <= sourceNode.depth) showToast("⚠️ Depth Error: Higher depth required.");
                else if (choice.Outcomes.some(o => o.NodeID === targetNodeId)) showToast("Already Linked");
                else {
                    recordHistory();
                    setChoices(prev => prev.map(c => c.ChoiceID === choiceId ? { ...c, Outcomes: [...c.Outcomes, { NodeID: targetNodeId, Weight: 100 }] } : c));
                    showToast(`Linked to ${targetNodeId}`);
                }
                setDraggingChoiceId(null); setDropTargetId(null);
            };

            const onChoiceDragOver = (e, choiceId) => {
                e.preventDefault(); e.stopPropagation();
                if (draggingChoiceId && draggingChoiceId !== choiceId) setDropTargetId(choiceId);
            };

            const onChoiceDrop = (e, targetChoiceId) => {
                e.stopPropagation(); e.preventDefault();
                const draggingId = draggingChoiceId;
                const targetChoice = choices.find(c => c.ChoiceID === targetChoiceId);
                if (targetChoice && draggingId !== targetChoiceId) {
                    recordHistory();
                    setChoices(prev => prev.map(c => c.ChoiceID === draggingId ? { ...c, ActiveTooltipType: "ShowChoiceAction", ActiveTooltipValue: targetChoiceId } : c));
                    showToast("Tooltip ref linked");
                }
                setDraggingChoiceId(null); setDropTargetId(null);
            };

            const handleChoiceHover = useCallback((e, choice) => {
                if (draggingChoiceId || editingChoiceCommentId) return;
                let content = "";
                if (choice.ActiveTooltipType === "ShowAction") {
                    content = `Outcomes: ${choice.Outcomes.map(o => o.NodeID).join(', ')}`;
                } else if (choice.ActiveTooltipType === "ShowChoiceAction" && choice.ActiveTooltipValue) {
                    content = `Tooltip Ref: ${choice.ActiveTooltipValue}`;
                }
                if (content) setTooltip({ show: true, x: e.clientX, y: e.clientY - 40, content });
            }, [draggingChoiceId, editingChoiceCommentId, choices]);

            const executeDelete = () => {
                recordHistory();
                const { type, id } = deleteModal.show ? deleteModal : { type: ctxMenu.type, id: ctxMenu.id };
                if (type === 'event') {
                    const remaining = events.filter(e => e.EventID !== id);
                    setEvents(remaining);
                    setNodes(nodes.filter(n => n.LinkedEventID !== id));
                    setChoices(choices.filter(c => !nodes.find(n => n.NodeID === c.LinkedNodeID && n.LinkedEventID === id)));
                    if (selectedEventId === id) setSelectedEventId(remaining[0]?.EventID || "");
                } else if (type === 'node') {
                    setNodes(nodes.filter(n => n.NodeID !== id));
                    setChoices(choices.filter(c => c.LinkedNodeID !== id));
                } else if (type === 'choice') {
                    const choice = choices.find(c => c.ChoiceID === id);
                    if (choice) {
                        setChoices(choices.filter(c => c.ChoiceID !== id));
                        setNodes(nodes.map(n => n.NodeID === choice.LinkedNodeID ? { ...n, ChoiceIDs: n.ChoiceIDs.filter(cid => cid !== id) } : n));
                    }
                }
                setDeleteModal({ show: false }); setCtxMenu({ show: false }); setSelectedElement(null);
            };

            const handleContextMenu = (e, type, id) => { e.preventDefault(); setCtxMenu({ show: true, x: e.clientX, y: e.clientY, type, id }); };
            useEffect(() => { const close = () => setCtxMenu({ show: false }); window.addEventListener('click', close); return () => window.removeEventListener('click', close); }, []);

            const saveWeightEdit = () => {
                if (!editingWeightData) return;
                recordHistory();
                const { choiceId, targetId } = editingWeightData;
                const newWeight = parseInt(tempValue) || 0;
                setChoices(choices.map(c => {
                    if (c.ChoiceID === choiceId) {
                        return { ...c, Outcomes: c.Outcomes.map(o => o.NodeID === targetId ? { ...o, Weight: newWeight } : o) };
                    }
                    return c;
                }));
                setEditingWeightData(null);
            };

            // --- JSON Import Logic ---
            const handleImport = () => {
                try {
                    const data = JSON.parse(importText);
                    const eventSheet = data["Event시트"] || [];
                    const nodeSheet = data["Node시트"] || [];
                    const choiceSheet = data["Choice시트"] || [];

                    if (!eventSheet.length && !nodeSheet.length) {
                        showToast("Invalid Data Format");
                        return;
                    }

                    recordHistory();

                    // 1. Process Nodes (Inject depth back)
                    const parsedNodes = nodeSheet.map(n => {
                        // Infer depth from last 2 digits if possible
                        const depth = parseInt(n.NodeID.slice(-2, -1)) || 0;
                        return { ...n, depth };
                    });

                    // 2. Process Choices (Parse outcomes and tooltip)
                    const parsedChoices = choiceSheet.map(c => {
                        // Parse OnSelectAction: ShowNextNode_ID_Prob,ShowNextNode_ID_Prob...
                        const outcomes = [];
                        if (c.OnSelectAction && c.OnSelectAction !== "None") {
                            const actionParts = c.OnSelectAction.split(',');
                            actionParts.forEach(part => {
                                const match = part.match(/ShowNextNode_(Node[a-zA-Z0-9]+)_(\d+)/);
                                if (match) {
                                    outcomes.push({ NodeID: match[1], Weight: parseInt(match[2]) || 100 });
                                }
                            });
                        }

                        // Parse ActiveTooltipType
                        let tooltipType = "None";
                        let tooltipValue = "";
                        if (c.ActiveTooltipType && c.ActiveTooltipType.startsWith("ShowChoiceAction_")) {
                            tooltipType = "ShowChoiceAction";
                            tooltipValue = c.ActiveTooltipType.replace("ShowChoiceAction_", "");
                        } else if (c.ActiveTooltipType === "ShowAction") {
                            tooltipType = "ShowAction";
                        }

                        return {
                            ...c,
                            Outcomes: outcomes,
                            ActiveTooltipType: tooltipType,
                            ActiveTooltipValue: tooltipValue
                        };
                    });

                    setEvents(eventSheet);
                    setNodes(parsedNodes);
                    setChoices(parsedChoices);
                    if (eventSheet.length > 0) setSelectedEventId(eventSheet[0].EventID);
                    
                    setShowImportModal(false);
                    setImportText("");
                    showToast("Data Imported Successfully");
                } catch (e) {
                    console.error(e);
                    alert("JSON parsing failed. Please check the format.");
                }
            };

            const [lines, setLines] = useState([]);
            const updateLines = useCallback(() => {
                const res = [];
                choices.forEach(choice => {
                    const nodeOfChoice = nodes.find(n => n.NodeID === choice.LinkedNodeID);
                    if (!nodeOfChoice || nodeOfChoice.LinkedEventID !== selectedEventId) return;
                    
                    choice.Outcomes.forEach(outcome => {
                        const startEl = elementRefs.current[choice.ChoiceID];
                        const endEl = elementRefs.current[outcome.NodeID];
                        const container = canvasRef.current;
                        if (startEl && endEl && container) {
                            const rectContainer = container.getBoundingClientRect();
                            const rectStart = startEl.getBoundingClientRect();
                            const rectEnd = endEl.getBoundingClientRect();
                            const x1 = rectStart.right - rectContainer.left;
                            const y1 = rectStart.top + (rectStart.height / 2) - rectContainer.top;
                            const x2 = rectEnd.left - rectContainer.left;
                            const y2 = rectEnd.top + (rectEnd.height / 2) - rectContainer.top;
                            
                            res.push({
                                id: `${choice.ChoiceID}-${outcome.NodeID}`,
                                choiceId: choice.ChoiceID,
                                targetId: outcome.NodeID,
                                d: `M ${x1} ${y1} C ${x1 + (x2-x1)/2} ${y1}, ${x1 + (x2-x1)/2} ${y2}, ${x2} ${y2}`,
                                weight: outcome.Weight,
                                lx: x1 + (x2 - x1) * 0.45,
                                ly: y1 + (y2 - y1) * 0.5 - 12
                            });
                        }
                    });
                });
                setLines(res);
            }, [choices, nodes, selectedEventId]);

            useEffect(() => {
                updateLines();
                const observer = new ResizeObserver(() => updateLines());
                if (canvasRef.current) observer.observe(canvasRef.current);
                return () => observer.disconnect();
            }, [updateLines]);

            const nodesByDepth = useMemo(() => {
                const group = {};
                nodes.filter(n => n.LinkedEventID === selectedEventId).forEach(n => {
                    if (!group[n.depth]) group[n.depth] = [];
                    group[n.depth].push(n);
                });
                return group;
            }, [nodes, selectedEventId]);

            const maxDepth = useMemo(() => {
                const depths = nodes.filter(n => n.LinkedEventID === selectedEventId).map(n => n.depth);
                return depths.length > 0 ? Math.max(...depths) : -1;
            }, [nodes, selectedEventId]);

            return (
                <div className="flex h-screen overflow-hidden select-none font-sans">
                    {toast.show && <div className="toast"><Icon name="Info" size={18} /> {toast.message}</div>}
                    {tooltip.show && <div className="tooltip bg-black text-white text-[10px] px-2 py-1 rounded shadow-xl font-mono whitespace-nowrap" style={{ left: tooltip.x, top: tooltip.y }}>{tooltip.content}</div>}
                    
                    {ctxMenu.show && (
                        <div className="ctx-menu animate-fadeIn" style={{ left: ctxMenu.x, top: ctxMenu.y }}>
                            <button onClick={executeDelete} className="w-full text-left px-3 py-2 hover:bg-red-50 text-red-600 text-xs font-bold flex items-center gap-2 transition-colors"><Icon name="Trash2" size={12} /> Delete</button>
                        </div>
                    )}

                    {editingWeightData && (
                        <div className="weight-input-box animate-fadeIn" style={{ left: editingWeightData.x, top: editingWeightData.y }}>
                            <div className="text-[9px] font-black text-blue-500 uppercase tracking-tighter mb-1 text-center">Set Weight</div>
                            <input autoFocus type="number" className="w-20 border-b-2 border-blue-200 outline-none text-sm font-bold text-center p-1" value={tempValue} onChange={(e) => setTempValue(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') saveWeightEdit(); else if (e.key === 'Escape') setEditingWeightData(null); }} onBlur={saveWeightEdit} />
                        </div>
                    )}

                    <aside className="w-64 bg-white border-r flex flex-col shrink-0">
                        <div className="p-4 border-b"><h1 className="font-black text-blue-600 flex items-center gap-2 italic uppercase tracking-tighter">Editor v2.8.6</h1></div>
                        <div className="flex-1 overflow-y-auto p-2 space-y-4">
                            {['Fixed', 'Random'].map(type => (
                                <div key={type}>
                                    <div className="text-[10px] font-black text-gray-400 mb-2 uppercase px-2 tracking-widest">{type} Events</div>
                                    {events.filter(e => e.EventType === type).map(ev => (
                                        <div key={ev.EventID} className="group relative mb-1">
                                            <button onClick={() => { setSelectedEventId(ev.EventID); setSelectedElement({ type: 'event', id: ev.EventID }); }}
                                                className={`w-full text-left p-3 rounded-xl transition-all pr-10 ${selectedEventId === ev.EventID ? 'bg-blue-600 text-white shadow-lg' : 'hover:bg-gray-100'}`}>
                                                <div className="text-xs font-bold truncate">{ev.EventID}</div>
                                                <div className={`text-[10px] truncate ${selectedEventId === ev.EventID ? 'text-blue-100' : 'text-gray-400'}`}>{ev.DevComment}</div>
                                            </button>
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); setDeleteModal({ show: true, type: 'event', id: ev.EventID }); }}
                                                className={`absolute right-2 top-1/2 -translate-y-1/2 p-2 opacity-0 group-hover:opacity-100 transition-all ${selectedEventId === ev.EventID ? 'text-white hover:text-red-200' : 'text-gray-300 hover:text-red-500'}`}
                                            >
                                                <Icon name="Trash2" size={14} />
                                            </button>
                                        </div>
                                    ))}
                                    <button onClick={() => createEvent(type)} className="w-full py-2 border-2 border-dashed border-gray-200 rounded-xl text-xs text-gray-400 hover:border-blue-300 hover:text-blue-500 transition-all flex items-center justify-center gap-1 mt-2 font-bold uppercase tracking-tighter">Add {type}</button>
                                </div>
                            ))}
                        </div>
                        <div className="p-4 bg-gray-50 border-t space-y-2">
                            <div className="flex gap-1 mb-2 font-black">
                                <button onClick={performUndo} disabled={undoStack.length === 0} className="flex-1 py-1.5 bg-white border border-gray-200 rounded-lg text-[10px] text-gray-600 hover:bg-gray-100 disabled:opacity-30">UNDO</button>
                                <button onClick={performRedo} disabled={redoStack.length === 0} className="flex-1 py-1.5 bg-white border border-gray-200 rounded-lg text-[10px] text-gray-600 hover:bg-gray-100 disabled:opacity-30">REDO</button>
                            </div>
                            {/* Import Button */}
                            <button onClick={() => setShowImportModal(true)} className="w-full py-2 bg-white border border-gray-300 text-gray-700 rounded-lg text-xs font-bold flex items-center justify-center gap-2 hover:bg-gray-100 transition-colors uppercase tracking-widest"><Icon name="Upload" size={14} /> IMPORT JSON</button>
                            <button onClick={downloadJSON} className="w-full py-2 bg-gray-800 text-white rounded-lg text-xs font-bold flex items-center justify-center gap-2 hover:bg-black transition-colors uppercase tracking-widest"><Icon name="Download" size={14} /> EXPORT JSON</button>
                        </div>
                    </aside>

                    <main className="flex-1 flex flex-col min-w-0 bg-gray-50 relative">
                        <header className="h-14 bg-white border-b flex items-center justify-between px-6 shrink-0 z-20">
                            <div className="flex items-center gap-3"><span className="text-sm font-bold text-gray-700">{selectedEventId || "SELECT EVENT"}</span>{selectedEventId && <span className="text-[10px] bg-blue-100 text-blue-600 px-2 py-0.5 rounded font-mono font-black uppercase tracking-tighter">{events.find(e=>e.EventID === selectedEventId)?.EventType}</span>}</div>
                            <div className="flex items-center gap-2"><button onClick={() => createNode(maxDepth + 1)} disabled={!selectedEventId} className="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold flex items-center gap-1 hover:bg-blue-700 disabled:opacity-30 shadow-md transition-all"><Icon name="Plus" size={14} /> NEW COLUMN</button></div>
                        </header>

                        <div className="flex-1 overflow-auto pattern-grid relative" onScroll={() => updateLines()}>
                            <div className="canvas-container p-12 flex gap-16 items-start" ref={canvasRef}>
                                <svg className="connection-layer">
                                    <defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orientation="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" /></marker></defs>
                                    {lines.map(line => (
                                        <g key={line.id} 
                                           onClick={() => setSelectedElement({ type: 'choice', id: line.choiceId })}
                                           onDoubleClick={(e) => { e.stopPropagation(); setEditingWeightData({ choiceId: line.choiceId, targetId: line.targetId, x: e.clientX, y: e.clientY }); setTempValue(line.weight.toString()); }}
                                           className="cursor-pointer pointer-events-auto group/line">
                                            <path d={line.d} fill="none" stroke="#3b82f6" strokeWidth="3" strokeOpacity="0.25" markerEnd="url(#arrowhead)" className="group-hover/line:stroke-opacity-100 transition-opacity" />
                                            {line.weight !== 100 && <text x={line.lx} y={line.ly} className="connection-label">{line.weight}</text>}
                                        </g>
                                    ))}
                                </svg>

                                {Array.from({ length: maxDepth + 1 }).map((_, dIdx) => (
                                    <div key={dIdx} className="flex flex-col gap-8 w-72 shrink-0">
                                        <div className="text-center px-4"><div className="text-[10px] font-black text-gray-300 uppercase tracking-[0.2em] mb-4">Depth {dIdx}</div>{dIdx > 0 && <button onClick={() => createNode(dIdx)} className="w-full py-2 border-2 border-dashed border-gray-200 rounded-xl text-[10px] text-gray-400 hover:bg-white hover:border-blue-300 hover:text-blue-500 transition-all font-bold uppercase tracking-widest">ADD NODE</button>}</div>
                                        {nodesByDepth[dIdx]?.map(node => (
                                            <div key={node.NodeID} ref={el => elementRefs.current[node.NodeID] = el}
                                                onClick={(e) => { e.stopPropagation(); setSelectedElement({ type: 'node', id: node.NodeID }); }}
                                                onContextMenu={(e) => handleContextMenu(e, 'node', node.NodeID)}
                                                onDragOver={(e) => onNodeDragOver(e, node.NodeID)} onDrop={(e) => onNodeDrop(e, node.NodeID)}
                                                className={`node-card bg-white rounded-2xl shadow-sm border-2 overflow-hidden transition-all relative ${selectedElement?.id === node.NodeID ? 'border-blue-500 ring-4 ring-blue-50 scale-105 shadow-xl' : 'border-gray-100 hover:border-gray-200'} ${dropTargetId === node.NodeID ? 'drop-target-active' : ''}`}>
                                                <div className="bg-gray-50 px-3 py-2 border-b flex justify-between items-center"><span className="text-[10px] font-mono font-bold text-gray-400">{node.NodeID}</span><span className="text-[9px] font-black bg-white px-1.5 py-0.5 rounded border border-gray-200 text-blue-500 uppercase">{node.NodeType}</span></div>
                                                <div className="p-4">
                                                    {editingNodeCommentId === node.NodeID ? (
                                                        <textarea autoFocus className="w-full p-2 text-xs border rounded-lg mb-4 outline-none focus:ring-2 focus:ring-blue-500 min-h-[80px] font-serif italic text-gray-600 bg-gray-50" 
                                                                  value={tempValue} 
                                                                  onChange={(e) => setTempValue(e.target.value)} 
                                                                  onBlur={() => { if (tempValue !== node.DevComment) { recordHistory(); setNodes(nodes.map(n => n.NodeID === node.NodeID ? {...n, DevComment: tempValue} : n)); } setEditingNodeCommentId(null); }} 
                                                                  onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) e.currentTarget.blur(); else if (e.key === 'Escape') setEditingNodeCommentId(null); }} />
                                                    ) : (
                                                        <p onDoubleClick={(e) => { e.stopPropagation(); setEditingNodeCommentId(node.NodeID); setTempValue(node.DevComment); }} 
                                                           className="text-xs text-gray-600 italic mb-4 whitespace-pre-wrap break-words cursor-text hover:bg-gray-50 rounded p-1 leading-relaxed">
                                                            "{node.DevComment}"
                                                        </p>
                                                    )}
                                                    <div className="space-y-1.5">
                                                        {node.ChoiceIDs.map(cid => {
                                                            const c = choices.find(x => x.ChoiceID === cid);
                                                            if(!c) return null;
                                                            const isEditingChoice = editingChoiceCommentId === cid;
                                                            return (
                                                                <div key={cid} ref={el => elementRefs.current[cid] = el}
                                                                    draggable={!isEditingChoice} onDragStart={(e) => onChoiceDragStart(e, cid)} 
                                                                    onDragOver={(e) => onChoiceDragOver(e, cid)} onDrop={(e) => onChoiceDrop(e, cid)} 
                                                                    onMouseEnter={(e) => !isEditingChoice && handleChoiceHover(e, c)} onMouseLeave={() => { setTooltip({ ...tooltip, show: false }); setDropTargetId(null); }} onContextMenu={(e) => handleContextMenu(e, 'choice', cid)} onClick={(e) => { e.stopPropagation(); setSelectedElement({ type: 'choice', id: cid }); }}
                                                                    className={`p-2 border rounded-xl text-[10px] flex justify-between items-center transition-all cursor-grab active:cursor-grabbing ${isEditingChoice ? 'ring-2 ring-blue-400 bg-white' : (selectedElement?.id === cid ? 'bg-orange-50 border-orange-400 text-orange-800 font-bold shadow-sm' : 'bg-white border-gray-100 hover:bg-gray-50')} ${dropTargetId === cid ? 'choice-drop-target-active' : ''}`}>
                                                                    <div className="flex items-center gap-1.5 overflow-hidden flex-1">
                                                                        {!isEditingChoice && <Icon name="MousePointer" size={10} className={`${selectedElement?.id === cid ? 'text-orange-400' : 'text-gray-300'} shrink-0`} />}
                                                                        {isEditingChoice ? (
                                                                            <input autoFocus className="w-full bg-transparent outline-none text-[10px] py-0.5 border-b border-blue-200" value={tempValue} onChange={(e) => setTempValue(e.target.value)} onBlur={() => { if (tempValue !== c.DevComment) { recordHistory(); setChoices(choices.map(item => item.ChoiceID === cid ? {...item, DevComment: tempValue} : item)); } setEditingChoiceCommentId(null); }} onKeyDown={(e) => { if (e.key === 'Enter') e.currentTarget.blur(); else if (e.key === 'Escape') setEditingChoiceCommentId(null); }} />
                                                                        ) : (
                                                                            <span className="flex-1 cursor-text font-bold whitespace-pre-wrap break-words py-1" onDoubleClick={(e) => { e.stopPropagation(); setEditingChoiceCommentId(cid); setTempValue(c.DevComment); }}>
                                                                                {c.DevComment}
                                                                            </span>
                                                                        )}
                                                                    </div>
                                                                    {!isEditingChoice && <div className="flex gap-1 ml-1 shrink-0">{c.ActiveTooltipType !== "None" && <Icon name="Info" size={10} className="text-purple-400" />}<Icon name="ArrowRight" size={10} className={c.Outcomes.length > 0 ? "text-blue-500" : "text-gray-200"} /></div>}
                                                                </div>
                                                            );
                                                        })}
                                                        {node.ChoiceIDs.length < 3 && <button onClick={(e) => { e.stopPropagation(); createChoice(node.NodeID); }} className="w-full py-1.5 border border-dashed border-gray-200 rounded-lg text-[9px] font-black text-gray-300 hover:bg-gray-50 hover:text-blue-400 transition-colors uppercase tracking-widest">Add Choice</button>}
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </main>

                    {selectedElement && viewMode === 'editor' && (
                        <aside className="w-80 bg-white border-l p-5 shadow-2xl overflow-y-auto animate-in slide-in-from-right duration-200">
                            <div className="flex justify-between items-center mb-6"><h2 className="text-[10px] font-black uppercase text-gray-400 tracking-[0.3em]">{selectedElement.type} PROPERTIES</h2><button onClick={() => setDeleteModal({ show: true, type: selectedElement.type, id: selectedElement.id })} className="text-gray-300 hover:text-red-500 transition-colors p-1 transition-all"><Icon name="Trash2" size={18} /></button></div>
                            <div className="space-y-6">
                                {selectedElement.type === 'event' && (() => {
                                    const ev = events.find(e => e.EventID === selectedElement.id);
                                    if (!ev) return null;
                                    return (
                                        <div className="space-y-4 animate-fadeIn">
                                            <PropField label="Event ID (Auto)" value={ev.EventID} readOnly />
                                            <PropField label="Dev Comment" value={ev.DevComment} onChange={v => { recordHistory(); setEvents(events.map(e => e.EventID === ev.EventID ? {...e, DevComment: v} : e)); }} type="textarea" />
                                            <PropField label="Start Condition" value={ev.StartCondition} onChange={v => { recordHistory(); setEvents(events.map(e => e.EventID === ev.EventID ? {...e, StartCondition: v} : e)); }} />
                                            <PropField label="Target Unit Condition" value={ev.TargetUnitCondition} onChange={v => { recordHistory(); setEvents(events.map(e => e.EventID === ev.EventID ? {...e, TargetUnitCondition: v} : e)); }} />
                                            <div className="grid grid-cols-2 gap-2">
                                                <PropField label="Weight" value={ev.Weight} onChange={v => { recordHistory(); setEvents(events.map(e => e.EventID === ev.EventID ? {...e, Weight: parseInt(v) || 0} : e)); }} type="number" />
                                                <PropField label="CoolDown" value={ev.CoolDown} onChange={v => { recordHistory(); setEvents(events.map(e => e.EventID === ev.EventID ? {...e, CoolDown: parseInt(v) || 0} : e)); }} type="number" />
                                            </div>
                                            <div className="flex items-center gap-2 pt-2"><input type="checkbox" checked={ev.IsRepeatable} onChange={e => { recordHistory(); setEvents(events.map(evnt => evnt.EventID === ev.EventID ? {...evnt, IsRepeatable: e.target.checked} : evnt)); }} className="w-4 h-4 text-blue-600 rounded border-gray-300" /><label className="text-[10px] font-black text-gray-500 uppercase">Is Repeatable</label></div>
                                        </div>
                                    )
                                })()}
                                {selectedElement.type === 'node' && (() => {
                                    const node = nodes.find(n => n.NodeID === selectedElement.id);
                                    if (!node) return null;
                                    return (
                                        <div className="space-y-4 animate-fadeIn">
                                            <PropField label="Node ID (Coord)" value={node.NodeID} readOnly />
                                            <PropField label="Node Type" value={node.NodeType} onChange={v => { recordHistory(); setNodes(nodes.map(n => n.NodeID === node.NodeID ? {...n, NodeType: v} : n)); }} type="select" options={["Normal", "Reward", "Combat", "End"]} />
                                            <PropField label="Dev Comment" value={node.DevComment} onChange={v => { recordHistory(); setNodes(nodes.map(n => n.NodeID === node.NodeID ? {...n, DevComment: v} : n)); }} type="textarea" />
                                        </div>
                                    )
                                })()}
                                {selectedElement.type === 'choice' && (() => {
                                    const choice = choices.find(c => c.ChoiceID === selectedElement.id);
                                    if (!choice) return null;
                                    return (
                                        <div className="space-y-4 animate-fadeIn">
                                            <PropField label="Choice ID" value={choice.ChoiceID} readOnly />
                                            <PropField label="Dev Comment" value={choice.DevComment} onChange={v => { recordHistory(); setChoices(choices.map(c => c.ChoiceID === choice.ChoiceID ? {...c, DevComment: v} : c)); }} type="textarea" />
                                            <div className="p-4 bg-gray-50 rounded-2xl border border-gray-100 space-y-3">
                                                <div className="flex justify-between items-center font-black text-gray-400 uppercase text-[9px] tracking-widest">Weights</div>
                                                {choice.Outcomes.length === 0 ? <div className="text-[9px] text-gray-400 italic py-2 text-center">No outcomes.</div> : (
                                                    <div className="space-y-2">
                                                        {choice.Outcomes.map((outcome, idx) => (
                                                            <div key={outcome.NodeID} className="bg-white p-2 rounded-xl border border-gray-200 shadow-sm flex items-center gap-2">
                                                                <div className="flex-1 min-w-0">
                                                                    <div className="text-[9px] font-mono font-bold text-blue-500 truncate">{outcome.NodeID}</div>
                                                                    <div className="flex items-center gap-2 mt-1">
                                                                        <span className="text-[8px] font-black text-gray-400 uppercase">W:</span>
                                                                        <input type="number" value={outcome.Weight} onChange={(e) => { recordHistory(); const newOutcomes = [...choice.Outcomes]; newOutcomes[idx].Weight = parseInt(e.target.value) || 0; setChoices(choices.map(c => c.ChoiceID === choice.ChoiceID ? {...c, Outcomes: newOutcomes} : c)); }} className="w-16 text-[10px] font-black border-b border-gray-200 outline-none text-blue-600 bg-transparent" />
                                                                    </div>
                                                                </div>
                                                                <button onClick={() => { recordHistory(); setChoices(choices.map(c => c.ChoiceID === choice.ChoiceID ? {...c, Outcomes: c.Outcomes.filter(o => o.NodeID !== outcome.NodeID)} : c)); }} className="text-red-300 hover:text-red-500 p-1"><Icon name="Trash2" size={14} /></button>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                            <PropField label="Active Condition" value={choice.ActiveCondition} onChange={v => { recordHistory(); setChoices(choices.map(c => c.ChoiceID === choice.ChoiceID ? {...c, ActiveCondition: v} : c)); }} />
                                            <PropField label="Active Tooltip Type" value={choice.ActiveTooltipType} onChange={v => { recordHistory(); setChoices(choices.map(c => c.ChoiceID === choice.ChoiceID ? {...c, ActiveTooltipType: v} : c)); }} type="select" options={["None", "ShowAction", "ShowChoiceAction"]} />
                                            <PropField label="Tooltip Value" value={choice.ActiveTooltipValue || ""} readOnly />
                                        </div>
                                    )
                                })()}
                            </div>
                        </aside>
                    )}

                    {showImportModal && (
                        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center p-6 animate-fadeIn">
                            <div className="bg-white w-full max-w-2xl rounded-3xl shadow-2xl overflow-hidden flex flex-col max-h-[80vh]">
                                <div className="p-6 border-b flex justify-between items-center font-bold">Import JSON<button onClick={() => setShowImportModal(false)}><Icon name="Plus" size={24} className="rotate-45" /></button></div>
                                <div className="p-6 space-y-4 text-xs text-gray-500">
                                    <p>내보냈던 DS_Events JSON 파일을 아래에 붙여넣으세요.</p>
                                    <textarea className="w-full h-64 p-4 bg-gray-50 border border-gray-200 rounded-2xl font-mono text-xs focus:ring-2 focus:ring-blue-500 outline-none" value={importText} onChange={(e) => setImportText(e.target.value)} placeholder='Paste JSON here...' />
                                </div>
                                <div className="p-6 bg-gray-50 border-t flex gap-3 justify-end"><button onClick={handleImport} className="px-6 py-2 rounded-xl text-sm font-bold bg-blue-600 text-white shadow-lg hover:bg-blue-700 transition-all">불러오기 (Load)</button></div>
                            </div>
                        </div>
                    )}
                    {deleteModal.show && (
                        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm z-[110] flex items-center justify-center p-6 animate-fadeIn">
                            <div className="bg-white w-full max-w-md rounded-3xl shadow-2xl p-8 text-center"><h3 className="text-xl font-bold mb-6 italic tracking-tighter">DELETE ITEM?</h3><div className="flex gap-3"><button onClick={() => setDeleteModal({ show: false })} className="flex-1 py-3 bg-gray-100 rounded-2xl font-bold transition-all">CANCEL</button><button onClick={executeDelete} className="flex-1 py-3 bg-red-600 text-white rounded-2xl font-bold shadow-lg shadow-red-200 transition-all">CONFIRM</button></div></div>
                        </div>
                    )}
                </div>
            );
        };

        const PropField = ({ label, value, onChange, readOnly = false, type = "text", options = [] }) => (
            <div>
                <label className="text-[10px] font-black text-gray-400 block mb-1.5 uppercase tracking-widest">{label}</label>
                {type === "textarea" ? (
                    <textarea value={value} onChange={e => onChange(e.target.value)} rows="3" readOnly={readOnly} className={`w-full p-3 bg-gray-50 border border-gray-100 rounded-2xl text-[11px] focus:ring-2 focus:ring-blue-500 outline-none transition-all ${readOnly ? 'opacity-50 cursor-not-allowed bg-gray-100 shadow-inner' : ''}`} />
                ) : type === "select" ? (
                    <select value={value} onChange={e => onChange(e.target.value)} className="w-full p-3 bg-gray-50 border border-gray-100 rounded-2xl text-[11px] font-bold focus:ring-2 focus:ring-blue-500 outline-none">{options.map(opt => <option key={opt} value={opt}>{opt}</option>)}</select>
                ) : (
                    <input type={type} value={value} onChange={e => onChange(e.target.value)} readOnly={readOnly} className={`w-full p-3 bg-gray-50 border border-gray-100 rounded-2xl text-[11px] focus:ring-2 focus:ring-blue-500 outline-none transition-all ${readOnly ? 'opacity-50 cursor-not-allowed font-mono bg-gray-100 shadow-inner' : ''}`} />
                )}
            </div>
        );

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
